# ref. [Effective Java 3/E]()

---

# [`Item7`] 다 쓴 객체 참조를 해제하라

---

#### 들어가기에 앞서...
자바의 가비지 컬렉터는 다 쓴 객체를 알아서 회수해준다. 자칫 메모라 관리에 더 이상 신경쓰지 않아도 된다고 오해할 수 있는데,<br>
이어지는 예제를 통해 시야를 넓혀보자.

## [1]. 스택 클래스의 메모리 누수

```java
// before
    public Object pop(){
        if(size == 0) throw new EmptyStackException();
        // 스택을 pop할 떄, 참조 해제가 이뤄지지 않는다.
        return elements[--size];
    }
```
- 특별한 문제가 없는 코드지만, `메모리 누수`가 발생할 수 있는 코드이다.
  - 스택에서 꺼내진 객체들을 `GC`가 회수하지 않는다.
- 이 스택을 사용하는 프로그램을 오래 실행하다 보면 점차 `GC`의 활동과 메모리 사용량이 늘어나 **성능 저하를 일으킬 수 있다**.
- 드물지만, `디스크 페이징`이나 `OutOfMemoryError`가 발생할 수 있다.

```java
// after
    public Object pop(){
        if(size == 0) throw new EmptyStackException();
        Object result = elements[--size];
        
        // 다 쓴 객체 참조 해제
        elements[size] = null;
        return result;
    }
```
##### null 처리의 장단점
👍 null 처리한 참조를 실수로 사용하면 프로그램은 `NullPointerException`을 던진다. ➡ 오류 발견이 용이<br>
👎 프로그램을 필요 이상으로 지저분하게 만들 수 있다. 객체 참조를 null 처리하는 경우는 예외적인 경우여야 한다.


### 스택 클래스가 메모리에 취약한 이유?
> 스택이 **자기 메모리를 직접 관리**하기 때문이다. ➡️ `GC`의 시점에선 비활성 객체 또한 **유효한 객체로 인식**한다.
- 일반적으로 `자기 메모리를 직접 관리하는 클래스`라면 개발자는 항시 **메모리 누수에 주의**해야 한다.

<br>

## [2]. 캐시의 메모리 누수
> 객체 참조를 캐시에 넣고, 해당 객체를 다 쓴 이후로도 처리를 안하는 경우
- 캐시 외부에서 키(key)를 참조하는 동안만 엔트리가 살아있는 캐시가 필요한 경우, `WeakHashMap`을 사용해 캐시를 만들자.<br>
  ➡️ 다쓴 엔트리는 그 즉시 자동으로 제거된다.

<br>

## [3]. 리스너(listener)와 콜백(Callback)
> 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다면, 콜백은 계속 쌓여간다.
- 콜백을 약한 참조(Weak Reference)로 저장하면 `GC`가 즉시 수거해간다.
  - `WeakHashMap`에 키로 저장하면 된다.

<br>

## 📝 요약
___
1. `메모리 누수`는 잘 드러나지 않아 발견하기 어렵다.
   - 코드 리뷰나 힙 프로파일러와 같은 디버깅을 동원해야만 발견되기도 한다.
2. 따라서, 미리 예방법을 익혀두고 충분한 설계를 하자 !
