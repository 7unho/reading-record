# ref. [Effective Java 3/E]()

---

# [`Item8`] finalizer와 cleaner 사용을 피하라

---
> 💡 `finalizer`와 `cleaner`의 사용을 지양하고, **`AutoCloseable`의 구현을 지향하자 !**

## 자바에서 제공하는 객체 소멸자
___
**[1]. finalizer**<br>
- 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.

**[2]. cleaner**<br>
- `finalizer`보다 덜 위험하지만, 이 또한 예측할 수 없고, 느리며, 일반적으로 불필요하다.

<br>

### 두 소멸자의 문제점
___
#### [1]. 실행 시점을 알 수 없다.
- `finalizer` 스레드의 수행 시점은 전적으로 `GC`에 달려있으며, 다른 애플리케이션 스레드보다 우선순위가 낮다.
기본적으로 **쓰지 말아야 한다.**
- `cleaner`는 자신을 수행할 스레드를 제어할 수 있다는 점에선 조금 낫지만, 여전히 **백그라운드에서 수행**되며, `GC`의 통제하에 있어 즉각 수행된다는 보장이 없다.

#### [2]. 심각한 성능문제
- `AutoCloseable` 객체를 생성하고 `GC`가 수거하기까지에 12ns가 걸린 반면, `finalizer`를 사용하면 550ns가 걸렸다고 한다.<br>
  `cleaner`또한 클래스의 모든 인스턴스를 수거하는 형태로 사용하면 성능은 `finalizer`와 비슷한 수준이다.

#### [3]. `finalizer`를 사용한 클래스는 `finalizer`공격에 노출되어 보안 문제를 일으킬 수 있다.

<br>

##### finalizer 공격 원리
1. 생성자나 직렬화 과정(`readobject`와 `readResolve`메서드[`12장`])에서 예외가 발생
2. 생성되다 만 객체에서 악의적인 하위 클래스의 `finalizer`가 수행될 수 있게 한다.
3. 해당 `finalizer`는 정적 필드에 자신의 참조를 할당하여 `GC`가 수집하지 못하게 막을 수 있다.

➡️ 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로도 충분하지만, `finalizer`가 있다면 그렇지 않다.
##### finalizer 공격 예방
💡 final이 아닌 클래스를 `finalizer`공격으로부터 예방하려면 **아무 일도 하지 않는 `finalize`메서드를 만들고 `final`로 선언하자.**

<br>

## AutoCloseable
___
> `AutoCloseable`을 구현해주고, 인스턴스의 사용이 끝나면 `close`메서드를 호출해주자
- 일반적으로 예외가 발생되더라도 제대로 종료되도록 `try-with-resources`를 사용해야 한다[`item9`]
- 각 인스턴스는 자신이 닫혔는지를 추적하는 것이 좋다.
  - `close`메서드에서 **해당 객체가 더 이상 유효하지 않음을 필드에 기록**하고,<br>
    다른 메서드는 해당 필드를 통해 **유효하지 않은 객체가 호출**되면 `IllegalStateException`을 던지는 방법

<br>

## 📝 요약
___
1. `try-with-resources[`**item9**`]`를 통한 `AutoCloseable`을 사용하자
2. `cleaner(~ 자바 8: finalizer)`는 안전망 역할이나, 중요하지 않은 네티이브 자원 회수용으로만 사용하자<br>
   ❗️불확실성과 성능 저하에 주의하며 사용